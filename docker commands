#############  docker commands  #############
=> Execute the docker as non root users
#sudo groupadd docker
#sudo usermod -aG docker $USER

=> install epel-repos
#yum install epel-release

=> Docker installation
#yum install docker -y

=> Checking docker service status 
#systemctl status docker

=> start to docker service
#systemctl start docker

=> checking docker version
#docker --version

=> Search specific operating system images
#docker search centos

=> Pull the the centos image 
#docker pull centos:6.9  (centos=repositry name 6.9=tag)

=> List of docker images in your current operating system
#docker images

=> Run a container
#docker run -it <image_name>    =>i=interactive t=terminal 
#docker run -it nginx

=> list of running containers
#docker ps

=> list of all container
#docker ps -a

=> To rename container
#docker rename <old_name> <new_name>
#docker rename nginx nginxcarbob

=> To remove container
#docker rm <container_name>
#docker rm nginx
#docker rm --force nginx

=> To remove all the stopped containers
#docker rm $(docker ps -a -q)

=> To remove docker image
#docker rmi <image_name>
#docker rmi nginx
#docker rmi -f nginx => -f=force

=> Update  the CPU information
#docker update --cpu-shares 256 -m 250M container-id

=> Docker logs of the container
#docker logs -f <container_name>
#docker logs -f nginx

=> Expose multiple ports
docker run -d -p 5000/tcp -p 53/udp image-name/id

=> Docker commits chnages to image
Do all the changes in the container
#docker commit container_id <image>:<new_tag>
else
#docker commit -m "What you did to the image" -a "Author Name" container_id repository/new_image_name

=> To see the stats of the docker container
#docker stats conatiner_id
CONTAINER ID        NAME                CPU %               MEM USAGE / LIMIT     MEM %               NET I/O             BLOCK I/O           PIDS
5ff1edf08ba0        packer_app_1        1.21%               39.48MiB / 6.364GiB   0.61%               738B / 0B           0B / 0B             3


############ Docker Network ############

=> type of netwirks
  -> Bridge (bridge is used to provide network connectvity to containers in the same host)
  -> host (host is to make sure that providing host network to the container the container directly participent in host n/w)
  -> macvlan ( macvlan it will be assign different macaddres to the container and directly participating on the physical n/w) 
  -> overlay (used in- swarm- (which in provide network connectivity in multipule docker enginees)

=> To list of network
#docker network ls

=> Network full information
#docker network inspect bridge

=> To display docker network options 
#docker network --help

=> Create new docker network
#docker network create < subnetrange> <network_name>
#docker network create --subnet 172.28.10.0/24 devopstrain

=> Network enable to container
#docker network connect <network_name> <container_name>
#docker network connect devopstrain nginx

=> Network disable to container
#docker network disconnect <network_name> <container_name>
#docker network disconnect  devopstrain nginx

=> Delete network 
#docker rm <netwirk_name>
#docker rm bridge

=> Delete the network which are not in use by any containers
#docker network prune

=> docker inspect specific information
#docker inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' $INSTANCE_ID
root@multipurpose:~/Packer# docker inspect  --format '{{.NetworkSettings.IPAddress}}' vigilant_roentgen
172.17.0.12

############ Docker Volume ############

=> To display docker volume options 
#docker volume --help

=> To display list of volumes 
#docker volume <command>
#docker volume ls

=> To create new volume 
#docker volume create <volume_name>
#docker volume create teststorage

=> To check new volume creation path
#ls -l /var/lib/docker/volume/teststorage/_data

=> To check volume complete info
#docker volume inspect <volume-name>
#docker volume inspect teststorage

=> remove a volume
# docker volume rm teststorage

=> create a container with volume
#docker run -d -it --name web-host -v myvol2:/data ubuntu:14.04 

////Notes 
Myvol2 : is created on the host id doenot exist
/data : is created in container if does not exist 

=> Login to container and create a new file
#docker exec -it web-host /bin/bash

=>create new file in the /data directory and exit container
#touch data/bhadra.txt
#ls data/
 exit
 
=> validate if file is there on your existing host file system
# ls -l /var/lib/docker/volumes/myvol2/_data

=>remove the web-host container and create a new container   
#docker  rm -f web-host
#docker run -d -it --name new-host -v myvol2:/data ubuntu:14.04

=> login to container and touch a file
#docker exec -it new-host ls -l /data

========================================== More commands =========================

=>First spin  new container with -v option
#docker run -ti -v <container-dir-path> --name  <container-name> <imageid> <shell>
#docker run -it -v /cookbook2 --name teststorage bc380a0d9076 /bin/bash

/cookbook2 is new folder(dont have to create)
data_vol is the name of the volume to created
bc380a0d9076 is the image id

=>create new container attach existing volume
# docker run -it --volumes-from teststorage centos /bin/bash

=>Mount volume in docker with ro permission
#docker run -it  -v /tmp:/data:ro ubuntu /bin/bash

=> To remove all unused volumes
#docker volume prune


=> docker provides 2 types of voules they are
   1. bind mount
   2. volume mount
   3. tmpfs (another one)
=> what is the difference between bind and volume

** if we use the volume mounts the folder or the directory what ever you monting into the container
   will be stored in a particular location which we called as a docker area ***
   
** we create a folder dirctely and mount that into container is called a bint mount
EX: /root/target:/app **

tmpfs:==> temparely file system ( it is going to create a temparly file syatem on system memory ) this is a very faster this is not a purchitans
          when ever container stopped data wiped
Example:# docker run -d --tmpfs /app --name nginx nginx

example2: #docker run -d -it --name devtest --mount type=tmpfs,tmpfs=4096,dest=/app nginx
   
volume:(-v)  syntax: source: destination: mode:
=======

mount: --mount syntax: type:volume/bind: source: destination: mode=rw,ro
======

# docker run -d -v myvol:/app --name test nginx
# docker inspect test
=> check mount details for test container
** mode: "z" sharebule for other containers
** mode: "0" not sharebule for other containers

=> docker inspect the mounts information 
root@multipurpose:/backup_sql# docker inspect -f {{.Mounts}} ec5039031118
[{bind  /backup_sql /tmp   true rprivate}]

=> Mount volume in docker with ro permission
#docker run -it  -v /tmp:/data:ro ubuntu /bin/bash




=> How to change the docker logs in debug mode.
1.stop the docker
#service docker stop

2.Start the daemon process
#dockerd -l debug &

=> passsing envirnment variable during docker run
#docker run -d -e "SERVER_NAME=statler" --name=statler fly-nodejs

=> copy file from host machine to docker container 
#docker cp <source_filename> <containerid>:<containerpath:
#docker cp file1 test:/data

=> copy file from host machine to docker container 
#docker cp <source-file-path> <container-id>:<destination-path>
#docker cp testfile e5bd8583a76b:/home/dataiku


###############   docker machine   ###############

=> TO share the file from host machine to docker container.
#docker run -it -v <host_path>: <container_path> <image_name> /bin/bash

=> ways Building the docker file
#docker build -t automatron .    => prasent dockerfile directory
#docker build -t automatron automatron/  => docker file full path
#docker build -t automatron https://github.com/madflojo/automatron.git  => docker file in gitlab

=> Expose port
#docker run -p <basemachine_port:container_port> image_name/id
#docker run -ti -p 8888:80 nginx /bin/bash

=> Expose multiple ports
#docker run -d -p 5000/tcp -p 53/udp image-name/id

=> How to create docker volume and share amoung multiple containers.

1. First spin  new container with -v option 
#docker run -it -v /cookbook2 --name data_vol  bc380a0d9076 /bin/bash

/cookbook2   => is new folder(dont have to create)
data_vol is  => the name of the volume to created
bc380a0d9076 => is the image id

2. TO inspect the volume create in the above command
root@multipurpose:/backup_sql# docker inspect -f {{.Mounts}} 296bf11809a3
[{volume 56a2852aeebf889a137b2204bc46f6343ad563793a70ef63bf00b86bd4ac9e65 /var/lib/docker/volumes/56a2852aeebf889a137b2204bc46f6343ad563793a70ef63bf00b86bd4ac9e65/_data /cookbook3 local  true }]
root@multipurpose:/backup_sql#

3. Create a new container now using  "--volume-from" option
#docker run -it  --volumes-from data_vol <image_id>  /bin/bash

**Notes:
New container will be create with with /cookbook2

=> How to copy data from docker container  to docker hosts
#docker cp  cookbook3_volume:/etc/imp .
#docker cp imp  cookbook3_volume:/tmp --from docker hosts to docker volume

=> Docker list volumes from all the containers
for contId in `docker ps -q`; do echo "Container Name: "   `docker ps -f "id=$contId" | awk '{print $NF}' | grep -v NAMES`; echo "Container Volume: " `docker inspect -f '{{.Config.Volumes}}' $contId`; docker inspect -f '{{ json .Mounts }}' $contId  | jq '.[]';   printf "\n"; done

Container Name:  redisclient
Container Volume:  map[]

Container Name:  redis1
Container Volume:  map[]

Container Name:  packer_app_1
Container Volume:  map[]

Container Name:  packer_redis_1
Container Volume:  map[/data:{}]
{
  "Type": "volume",
  "Name": "1bf8d0750b3052030450b2b5fcab1cd40ef65116f7d0010dc7317d0d03db20a4",
  "Source": "/var/lib/docker/volumes/1bf8d0750b3052030450b2b5fcab1cd40ef65116f7d0010dc7317d0d03db20a4/_data",
  "Destination": "/data",
  "Driver": "local",
  "Mode": "",
  "RW": true,
  "Propagation": ""
}

##########   Dockerfile   ##########
what is the difference between RUN CMD and ENTRYPOINT
RUN executes command(s) in a new layer and creates a new image. E.g., it is often used for installing software packages.
example
RUN apt-get install python3

--shell form
/bin/sh -c <command>
example
ENV name John Dow
ENTRYPOINT echo "Hello, $name"

--Exec form 
<instruction> ["executable", "param1", "param2", ...]
example
RUN ["apt-get", "install", "python3"]
CMD ["/bin/echo", "Hello world"]
ENTRYPOINT ["/bin/echo", "Hello world"]

ENTRYPOINT is the program to run the given command. It is used when yo want to run a container as an executable.

Difference between ADD and COPY
That’s because it’s more transparent than ADD. COPY only supports the basic copying of local files into the container, while ADD has some features (like local-only tar extraction and remote URL support) that are not immediately obvious. Consequently, the best use for ADD is local tar file auto-extraction into the image, as in ADD rootfs.tar.xz /.


     +------------+  docker build   +--------------+  docker run -dt   +-----------+  docker exec -it   +------+
    | Dockerfile | --------------> |    Image     | --------------->  | Container | -----------------> | Bash |
    +------------+                 +--------------+                   +-----------+                    +------+
                                     ^
                                     | docker pull
                                     |
                                   +--------------+
                                   |   Registry   |
                                   +--------------+
                                   
##Override the ENTRYPOINT at runtime, using docker run
docker run --entrypoint "/bin/ls -al /root" debian-- This will create problem
This command has to convert to 
docker run --entrypoint "/bin/ls" debian -al /root

########## Docker compose ##########
Compose is a tool for defining and running multi-container Docker applications. With Compose, you use a YAML file to configure your application’s services. Then, with a single command, you create and start all the services from your configuration.

=>By defaults docker up command will get all in the foreground
use docker compose up -d to get the console back
root@multipurpose:~/Packer# docker-compose up -d
Starting packer_redis_1
Starting packer_app_1
root@multipurpose:~/Packer#
root@multipurpose:~/Packer# docker ps
CONTAINER ID        IMAGE                        COMMAND                  CREATED             STATUS              PORTS                    NAMES
b89e05bbc1e8        takacsmark/flask-redis:1.0   "/bin/sh -c 'flask r…"   23 seconds ago      Up 2 seconds        0.0.0.0:5000->5000/tcp   packer_app_1
5e19bb2a6450        redis:4.0.11-alpine          "docker-entrypoint.s…"   23 seconds ago      Up 2 seconds        6379/tcp                 packer_redis_1
root@multipurpose:~/Packer#

root@multipurpose:~/Packer# docker-compose stop
Stopping packer_app_1 ... done
Stopping packer_redis_1 ... done

root@multipurpose:~/Packer# docker-compose down
Stopping packer_app_1 ... done
Stopping packer_redis_1 ... done
Removing packer_app_1 ... done
Removing packer_redis_1 ... done
Removing network packer_default
root@multipurpose:~/Packer#

root@multipurpose:~/Packer# docker-compose scale redis=4
Creating and starting packer_redis_2 ... done
Creating and starting packer_redis_3 ... done
Creating and starting packer_redis_4 ... done

root@multipurpose:~/Packer# docker ps
CONTAINER ID        IMAGE                        COMMAND                  CREATED             STATUS              PORTS                    NAMES
2ac1791ab1c3        redis:4.0.11-alpine          "docker-entrypoint.s…"   5 seconds ago       Up 3 seconds        6379/tcp                 packer_redis_4
7210d10b911d        redis:4.0.11-alpine          "docker-entrypoint.s…"   5 seconds ago       Up 4 seconds        6379/tcp                 packer_redis_3
6b0481b7bf84        redis:4.0.11-alpine          "docker-entrypoint.s…"   5 seconds ago       Up 3 seconds        6379/tcp                 packer_redis_2
e3ba2e43af56        takacsmark/flask-redis:1.0   "/bin/sh -c 'flask r…"   2 minutes ago       Up 2 minutes        0.0.0.0:5000->5000/tcp   packer_app_1
1bd1e48f22fe        redis:4.0.11-alpine          "docker-entrypoint.s…"   2 minutes ago       Up 2 minutes        6379/tcp                 packer_redis_1
root@multipurpose:~/Packer#

=> docker scale down
root@multipurpose:~/Packer# docker-compose scale redis=1
Stopping and removing packer_redis_2 ... done
Stopping and removing packer_redis_3 ... done
Stopping and removing packer_redis_4 ... done
root@multipurpose:~/Packer# docker ps
CONTAINER ID        IMAGE                        COMMAND                  CREATED             STATUS              PORTS                    NAMES
e3ba2e43af56        takacsmark/flask-redis:1.0   "/bin/sh -c 'flask r…"   3 minutes ago       Up 3 minutes        0.0.0.0:5000->5000/tcp   packer_app_1
1bd1e48f22fe        redis:4.0.11-alpine          "docker-entrypoint.s…"   3 minutes ago       Up 3 minutes        6379/tcp                 packer_redis_1
root@multipurpose:~/Packer#

we can scale multiple service in single command
docker-compose scale node1=3 node2=3

=> To attach the volume to container 
#docker run -dti <server-name> <mount_point> <image-name>
#docker run -dti --name testserver --mount source=teststorage,target=/teststorage nginx:latest


=> To assigen specific permissions
#docker run -dti <server-name> <mount_point> <permission_type> <image-name>
#docker run -dti --name testserver --mount source=teststorage,target=/teststorage,readonly nginx:latest















